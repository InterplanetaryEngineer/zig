// This is a port and adaption of Ulf Adams's "ryu" float parser:
// https://github.com/ulfjack/ryu
// which is licensed under the Boost Software License.

// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

const std = @import("../std.zig");
const assert = std.debug.assert;
const math = std.math;

usingnamespace @import("ryu_tables.zig");

const use_tables = std.builtin.mode != .ReleaseSmall;


pub const FloatProperties = struct {
    mantissa_bits: comptime_int,
    exponent_bits: comptime_int,
    exponent_bias: comptime_int,
    significant_digits: comptime_int,
    min_dec_exponent: comptime_int,
    max_dec_exponent: comptime_int,
    max_exponent: comptime_int,
    integer: type,
    T: type,
};

/// Constants used in handling the respective type
pub fn PropertiesOf(comptime float: type) FloatProperties {
    return switch (float) {
        f16 => .{
            .T = f16,
            .mantissa_bits = 10,
            .exponent_bits = 5,
            .exponent_bias = 15,
            .significant_digits = 5,
            .min_dec_exponent = -11,
            .max_dec_exponent = 7,
            .integer = u16
        },
        f32 => .{
            .T = f32,
            .mantissa_bits = 23,
            .exponent_bits = 8,
            .exponent_bias = 127,
            .significant_digits = 9,
            .min_dec_exponent = -46,
            .max_dec_exponent = 40,
            .max_exponent = 0xff,
            .integer = u32
        },

        f64 => .{
            .T = f64,
            .mantissa_bits = 52,
            .exponent_bits = 11,
            .exponent_bias = 1023,
            .significant_digits = 17,
            .min_dec_exponent = -324,
            .max_dec_exponent = 310,
            .max_exponent = 0x7ff,
            .integer = u64
        },
        f128 => .{
            .T = f128,
            .mantissa_bits = 112,
            .exponent_bits = 15,
            .exponent_bias = 16383,
            .significant_digits = 36,
            .min_dec_exponent = -4967,
            .max_dec_exponent = 4931,
            .max_exponent = 0x7fff,
            .integer = u128
        },

        else => @compileError("Expected floating point type, got: " ++ @typeName(float))
    };
}

pub fn floor_log2(comptime T: type, value: T) i32 {
    return @typeInfo(T).Int.bits - 1 - @clz(T, value);
}

/// floor(e * log_2(5))
pub fn log2pow5(e: u32) i32 {
    // This approximation works up to the point that the multiplication overflows at e = 3529.
    // If the multiplication were done in 64 bits, it would fail at 5^4004 which is just greater
    // than 2^9297.
    assert(e >= 0);
    assert(e <= 3528);
    return @intCast(i32, (e * 1217359) >> 19);
}

/// ceil(e * log_2(5))
pub fn ceil_log2pow5(e: u32) i32 {
  return log2pow5(e) + 1;
}

/// Is value divisible by 2^p?
pub fn multipleOfPowerOf2(comptime T: type, value: T, p: i32) bool {
    // This is guranteed when p < 0 and and cannot occur when p >= bitwidth.
    if (p < 0) {
        return true;
    }
    if (p >= @typeInfo(T).Int.bits) {
        return false;
    }

    return (value & ((@as(T, 1) << @intCast(math.Log2Int(T), p)) - 1)) == 0;
}

/// Is value is divisible by 5^p?
pub fn multipleOfPowerOf5(comptime T: type, value: T, p: u32) bool {
    switch (T) {
        u32 =>
            return pow5factor_32(value) >= p,
        u64 =>
            return pow5factor_64(value) >= p,
        u128 =>
            return pow5factor_128(value) >= p,
        else =>
            @compileError("oops")
    }
}

/// Highest power of 5 that is a factor of x
fn pow5factor_32(x: u32) u32 {
    var value = x;
    var count: u32 = 0;
    while (true) : (count += 1) {
        assert(value != 0);
        const q = value / 5;
        const r = value % 5;

        if (r != 0) {
            break;
        }
        value = q;
    }
    return count;
}

// TODO: Explain this awesome magic
/// Highest power of 5 that is a factor of x
fn pow5factor_64(x: u64) u32 {
    // 5 * m_inv_5 = 1 (mod 2^64)
    const m_inv_5: u64 = 14757395258967641293;
    // #{ n | n = 0 (mod 2^64) } = 2^64 / 5
    const n_div_5: u64 = 3689348814741910323;

    var value = x;
    var count: u32 = 0;

    while (true): (count += 1) {
        assert(value != 0);
        value = value *% m_inv_5;

        if (value > n_div_5) {
            break;
        }
    }
    return count;
}

// TODO: accurate enough for f128?
/// Highest power of 5 that is a factor of x
fn pow5factor_128(x: u128) u32 {
    // 5 * m_inv_5 = 1 (mod 2^128)
    const m_inv_5: u128 = 272225893536750770770699685945414569165;
    // #{ n | n = 0 (mod 2^128) } = 2^128 / 5
    const n_div_5: u128 = 68056473384187692692674921486353642291;

    var value = x;
    var count: u32 = 0;

    while (true): (count += 1) {
        assert(value != 0);
        value = value *% m_inv_5;

        if (value > n_div_5) {
            break;
        }
    }
    return count;
}






/// m * 5^p / 2^q
pub fn mulPow5divPow2(comptime T: type, m: T, p: u32, q: i32) T {
    const bitcount = switch (T) {
        u32 => 61,
        u64 => 125,
        else =>
            @compileError("Not implemented")
    };
    const j = q - ceil_log2pow5(p) + bitcount;

    const pow = switch (T) {
        u32 =>
            split(u32, FLOAT_POW5_SPLIT[p]),
        u64 =>
            if (use_tables)
                DOUBLE_POW5_SPLIT[p]
            else
                computePow5(p),
        else => unreachable
    };
    return mulShift(T, m, pow, j);
}
// TODO: accurate enough for f128 (15 bit exponent)?
fn computePow5(p: u32) [2]u64 {
    const table_size = @as(u32, DOUBLE_POW5_TABLE.len);
    const base = p / table_size;
    const base2 = base * table_size;
    const offset = p - base2;
    const mul = DOUBLE_POW5_SPLIT2[base];
    if (offset == 0) {
        return mul;
    }
    const m = DOUBLE_POW5_TABLE[offset]; // 5^offset
    const b0 = @as(u128, m) * mul[0];
    const b2 = @as(u128, m) * mul[1];
    const delta = ceil_log2pow5(p) - ceil_log2pow5(base2);
    const shift = @intCast(u7, delta);

    const combined = (b0 >> shift) + (b2 << (64 - shift));
    const shiftedSum = combined + ((POW5_OFFSETS[p / 16] >> @intCast(u5, (p % 16) << 1)) & 3);

    return [2]u64{ @truncate(u64, shiftedSum), @intCast(u64, shiftedSum >> 64) };
}

/// m / (5^p * 2^q)
pub fn mulPow5InvDivPow2(comptime T: type, m: T, p: u32, q: i32) T {
    const bitcount = switch (T) {
        u32 => 59,
        u64 => 125,
        else =>
            @compileError("Not implemented")
    };
    const j = q + log2pow5(p) + bitcount;

    const inv_pow = switch (T) {
        u32 =>
            split(u32, FLOAT_POW5_INV_SPLIT[p]),
        u64 =>
            if (use_tables)
                DOUBLE_POW5_INV_SPLIT[p]
            else
                computeInvPow5(p),

        else => @compileError("Oops.")
    };
    return mulShift(T, m, inv_pow, j);
}
// TODO: accurate enough for f128?
fn computeInvPow5(p: u32) [2]u64 {
    const table_size = @as(u32, DOUBLE_POW5_TABLE.len);
    const base = (p + table_size - 1) / table_size;
    const base2 = base * table_size;
    const offset = base2 - p;
    const mul = DOUBLE_POW5_INV_SPLIT2[base]; // 1/5^base2
    if (offset == 0) {
        return mul;
    }
    const m = DOUBLE_POW5_TABLE[offset]; // 5^offset
    const b0 = @as(u128, m) * (mul[0] - 1);
    const b2 = @as(u128, m) * mul[1]; // 1/5^base2 * 5^offset = 1/5^(base2-offset) = 1/5^p
    const delta = log2pow5(base2) - log2pow5(p);
    const shift = @intCast(u7, delta);

    const combined = ((b0 >> shift) + (b2 << (64 - shift)));
    const off_shift = @intCast(u5, (p % 16) << 1);
    const shiftedSum = combined + 1 + ((POW5_INV_OFFSETS[p / 16] >> off_shift) & 3);

    return [2]u64 { @truncate(u64, shiftedSum), @intCast(u64, (shiftedSum >> 64)) };
}

// (m * factor) >> shift (avoiding overflow)
fn mulShift(comptime T: type, m: T, factor: [2]T, shift: i32) T {
    const bitWidth = @typeInfo(T).Int.bits;
    const shiftType = math.Log2Int(T);

    const bits0 = @as(Extended(T), m) * factor[0];
    const bits1 = @as(Extended(T), m) * factor[1];

    const shiftedSum = ((bits0 >> bitWidth) + bits1) >> @intCast(shiftType, shift - bitWidth);
    return @intCast(T,  shiftedSum);
}

fn Extended(comptime T: type) type {
    return std.meta.Int(.unsigned, @typeInfo(T).Int.bits * 2);
}
fn join(comptime T: type, x: [2]T) Extended(T) {
    const low = @as(Extended(T), x[0]);
    const high = @as(Extended(T), x[1]);
    return low + (high << @typeInfo(T).Int.bits);
}
fn split(comptime T: type, x: Extended(T)) [2]T {
    return [2]T { @truncate(T, x), @intCast(T, (x >> @typeInfo(T).Int.bits)) };
}
